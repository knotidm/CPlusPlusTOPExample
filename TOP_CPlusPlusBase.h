/*
 * Produced by:
 *
 * 				Derivative Inc
 *				401 Richmond Street West, Unit 386
 *				Toronto, Ontario
 *				Canada   M5V 3A8
 *				416-591-3555
 *
 * NAME:				TOP_CPlusPlusBase.h
 *
 */

/*******
	Do not edit this file directly!
	Make a subclass of TOP_CPlusPlusBase instead, and add your own data/function

	Derivative Developers:: Make sure the virtual function order
	stays the same, otherwise changes won't be backwards compatible
	********/

#ifndef __TOP_CPlusPlusBase__
#define __TOP_CPlusPlusBase__
#include <windows.h>
#include <cstdio>
#define DLLEXPORT __declspec (dllexport)
#define TOP_CPLUSPLUS_API_VERSION	1

class TOP_CPlusPlusBase;
class TOP_NodeInfo;

// These are the definitions for the C-functions that are used to
// load the library and create instances of the object you define
typedef int(__cdecl *GETTOPAPIVERSION)(void);
typedef TOP_CPlusPlusBase* (__cdecl *CREATETOPINSTANCE)(const TOP_NodeInfo*);
typedef void(__cdecl *DESTROYTOPINSTANCE)(TOP_CPlusPlusBase*);
// These classes are used to pass data to/from the functions you will define
class TOP_NodeInfo
{
public:
	// The full path to the node
	const char*		nodeFullPath;
	// A unique ID representing the node, no two nodes will ever
	// have the same ID in a single Touch instance.
	unsigned int	uniqueNodeId;
	// This is the handle to the main TouchDesigner window.
	// It's possible this will be 0 the first few times the node cooks,
	// incase it cooks while Touch is still loading up
	HWND			mainWindowHandle;
private:
	int				reserved[19];
};
// Touch will select the best pixel format based on the options you give
// Not all possible combinations of channels/bit depth are possible,
// so you get the best choice supported by your card
class TOP_OutputFormat
{
public:
	int				width;
	int				height;
	// The aspect ratio of the TOP's output
	float			aspectX;
	float			aspectY;
	// The anti-alias level.
	// 1 means no anti-alaising
	// 2 means '2x', etc., up to 32 right now
	int				antiAlias;
	// Set true if you want this channel, false otherwise
	// The channel may still be present if the combination you select
	// isn't supported by the card (blue only for example)
	bool			redChannel;
	bool			greenChannel;
	bool			blueChannel;
	bool			alphaChannel;
	// The number of bits per channel. 
	// Touch will select the closest supported number of bits based on
	// your cards capabilities
	unsigned		bitsPerChannel;
	// Set to true if you want a floating point format.
	// Some bit precisions don't support floating point (8-bit for example)
	// while others require it (32-bit)
	bool			floatPrecision;
	// If you want to use multiple render targets, you can set this
	// greater than one
	int				numColorBuffers;
	// The number of bits in the depth buffer.
	// 0 for no depth buffer
	int				depthBits;
	// The number of bits in the stencil buffer
	// 0 for no stencil buffer, if this is > 0 then
	// it will also cause a depth buffer to be created
	// even if you have depthBits == 0
	int				stencilBits;
private:
	int				reserved[20];
};
// This class will tell you the actualy output format
// that was chosen.
class TOP_OutputFormatSpecs
{
public:
	int				width;
	int				height;
	float			aspectX;
	float			aspectY;
	int				antiAlias;
	int				redBits;
	int				blueBits;
	int				greenBits;
	int				alphaBits;
	bool			floatPrecision;
	int				numColorBuffers;
	int				depthBits;
	int				stencilBits;
	// This is the index of the FBO that TouchDesigner has bound for you
	// You can use this to re-bind the FBO incase you are using some of
	// your own for intermediate results.
	unsigned int	FBOIndex;
private:
	int				reserved[19];
};

class TOP_GeneralInfo
{
public:
	// Set this to true if you want the TOP to cook every frame, even
	// if none of it's inputs/parameters are changing
	bool			cookEveryFrame;
	// Touch will clear the color/depth buffers before calling
	// execute(), as an optimization you can disable this, if you know
	// you'll be overwritting all the data or calling clear yourself
	bool			clearBuffers;
	// Set this to true if you want Touch to create mipmaps for all the
	// TOPs that are passed into execute() function
	bool			mipmapAllTOPs;
	// Set this to true if you want the CHOP to cook every frame, if asked
	// (someone uses it's output)
	// This is different from 'cookEveryFrame', which causes the node to cook
	// every frame no matter what
	bool			cookEveryFrameIfAsked;
	// When setting the output texture size using the node's common page
	// if using 'Input' or 'Half' options for example, it uses the first input
	// by default. You can use a different input by assigning a value 
	// to inputSizeIndex.
	int				inputSizeIndex;
private:
	int				reserved[20];
};

class TOP_TOPInput
{
public:
	const char*		nodeFullPath;
	int				inputNumber;
	int				width;
	int				height;
	// The OpenGL Texture index for this TOP.
	unsigned int	textureIndex;
private:
	int				reserved[20];
};

class TOP_FloatInput
{
public:
	const char*		name;
	int				inputNumber;
	// Will contain the 4 floats in the parameter.
	float			values[4];
private:
	int				reserved[20];
};

class TOP_CHOPInput
{
public:
	const char*		nodeFullPath;
	int				inputNumber;
	int				numChannels;
	int				length;
	float			sampleRate;
	// This is an array of float arrays. The array is 'numChannels' long
	// while each individual array within the array is 'length' long
	// e.g: channels[1][10] will refer to the 11th sample in the 2nd channel 
	const float**	channels;
	// This is an array of const char* which give you the names of the
	// channels. The length of the array is 'numChannels' long.
	// For example names[1] is the name of the 2nd channel
	const char**	names;
private:
	int				reserved[19];
};

class TOP_StringInput
{
public:
	const char*		name;
	int				inputNumber;
	const char*		value;
private:
	int				reserved[20];
};

class TOP_InputArrays
{
public:
	int						numFloatInputs;
	// floatInputs is an array of TOP_FloatInputs objects, 'numFloatInputs' long
	// e.g floatInputs[0].name
	const TOP_FloatInput*	floatInputs;
	// The rest of these are similar to the floatInputs description
	int						numTOPInputs;
	const TOP_TOPInput*		TOPInputs;
	int						numCHOPInputs;
	const TOP_CHOPInput*	CHOPInputs;
	int						numStringInputs;
	const TOP_StringInput*	stringInputs;
private:
	int				reserved[100];
};

class TOP_InfoCHOPChan
{
public:
	char*			name;
	float			value;
private:
	int				reserved[10];
};

class TOP_InfoDATSize
{
public:
	// Set this to the size you want the table to be
	int				rows;
	int				cols;
	// Set this to true if you want to return DAT entries on a column
	// by column basis.
	// Otherwise set to false, and you'll be expected to set them on
	// a row by row basis.
	// DEFAULT : false
	bool			byColumn;
private:
	int				reserved[10];
};

class TOP_InfoDATEntries
{
public:
	// This is an array of char* pointers which you are expected to assign
	// The start off as NULL, you need to allocate or assign constant/statis
	// strings to them
	// e.g values[1] = "myColumnName";
	char**			values;
private:
	int				reserved[10];
};

/*** DO NOT EDIT THIS CLASS, MAKE A SUBCLASS OF IT INSTEAD ***/
class TOP_CPlusPlusBase
{
protected:
	TOP_CPlusPlusBase(){}
public:
	virtual ~TOP_CPlusPlusBase(){}
	// BEGIN PUBLIC INTERFACE
	// Some general settings can be assigned here by setting memebers of
	// the TOP_GeneralInfo class that is passed in
	virtual void		getGeneralInfo(TOP_GeneralInfo*){}
	// This function is called so the class can tell the TOP what
	// kind of buffer it wants to output into.
	// Touch will try to find the best match based on the specifications
	// given.
	// Return true if you specify the output here
	// Return false if you want the output to be set by the TOP's parameters
	// The TOP_OutputFormat class is pre-filled with what the TOP would
	// output if you return false, so you can just tweak a few settings
	// and return true if you want
	virtual bool		getOutputFormat(TOP_OutputFormat*){ return false; }
	// In this function you do whatever you want to fill the framebuffer
	// 
	// See the TOP_InputArrays class definition for more details on it's
	// contents
	virtual void		execute(const TOP_OutputFormatSpecs*, const TOP_InputArrays*, void* reserved) = 0;
	// Override these methods if you want to output values to the Info CHOP/DAT
	// returning 0 means you dont plan to output any Info CHOP channels
	virtual int			getNumInfoCHOPChans(){ return 0; }
	// Specify the name and value for CHOP 'index',
	// by assigning something to 'name' and 'value' members of the
	// TOP_InfoCHOPChan class pointer that is passed (it points
	// to a valid instance of the class already.
	// the 'name' pointer will initially point to NULL
	// you must allocate memory or assign a constant string
	// to it.
	virtual void		getInfoCHOPChan(int index, TOP_InfoCHOPChan *chan){}
	// Return false if you arn't returning data for an Info DAT
	// Return true if you are.
	// Fill in members of the TOP_InfoDATSize class to specify the size
	virtual bool		getInfoDATSize(TOP_InfoDATSize *infoSize){ return false; }
	// You are asked to assign values to the Info DAT 1 row or column at a time
	// The 'byColumn' variable in 'getInfoDATSize' is how you specify
	// if it is by column or by row.
	// 'index' is the row/column index
	// 'nEntries' is the number of entries in the row/column
	virtual void		getInfoDATEntries(int index, int nEntries, TOP_InfoDATEntries *entries){}
	// You can use this function to put the node into a warning state
	// with the returned string as the message.
	// Return NULL if you don't want it to be in a warning state.
	virtual const char* getWarningString(){ return NULL; }
	// You can use this function to put the node into a error state
	// with the returned string as the message.
	// Return NULL if you don't want it to be in a error state.
	virtual const char* getErrorString(){ return NULL; }
	// Use this function to return some text that will show up in the
	// info popup (when you middle click on a node)
	// Return NULL if you don't want to return anything.
	virtual const char* getInfoPopupString(){ return NULL; }
private:
	// Reserved for future features
	virtual int		reservedFunc4() { return 0; }
	virtual int		reservedFunc5() { return 0; }
	virtual int		reservedFunc6() { return 0; }
	virtual int		reservedFunc7() { return 0; }
	virtual int		reservedFunc8() { return 0; }
	virtual int		reservedFunc9() { return 0; }
	virtual int		reservedFunc10() { return 0; }
	virtual int		reservedFunc11() { return 0; }
	virtual int		reservedFunc12() { return 0; }
	virtual int		reservedFunc13() { return 0; }
	virtual int		reservedFunc14() { return 0; }
	virtual int		reservedFunc15() { return 0; }
	virtual int		reservedFunc16() { return 0; }
	virtual int		reservedFunc17() { return 0; }
	virtual int		reservedFunc18() { return 0; }
	virtual int		reservedFunc19() { return 0; }
	virtual int		reservedFunc20() { return 0; }
	int				reserved[400];
};
#endif